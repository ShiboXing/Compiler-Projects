
jflex must be installed and could be run by "jflex <flex_file>" under the current directory
the directory must contain a java-cup-11a.jar

BUILD: run Makefile (dependencies are apocalypse, parser.cup, ADriver.java java-cup-11a.jar)
    make
RUN:
    java -classpath .:java-cup-11a.jar ADriver <input_file_name>

                                OR
    (run with test.asm)
    make run

DESCPRITION:

this program is an interpreter for a small set of MIPS language. It is divided into Lexeing, parsing and interpreting.
The lexer generated by apocalypse.flex woudl replace all the tokens with grammar symbols that could be read in by
parser. The parser then fits all the symbols into instruction sentences and returns this instruction list to the 
main driver, where instructions would be executed one by one.


IMPLEMENTATION APPROACHES:

Apocalypse.jflex

the lexer speicification file of the program. It matches all the legal code tokens with either regular expressions
or arbitrary keywords and returns them as Symbol objects. The symbol ID integers used are stored in the sym.java which
is generated by the parser file. The symbols' values are called directly by their corresponding variable names, e.g.
EOF's value is sym.EOF
Most of the symbols are MIPS operation keywords, thus arbitrary. Other than that, 4 available registers
$r0-$r4 are also matched with 4 constant strings. The Symbols with variable strings are immediate numbers and labels.
Immediate numbers are negative or positive decimal integers, or hexadecimal integers. 
Labels are matched as an identifier ends with a colon, where an identifier is formed by any combination
of alphabatical letters and digits which starts with a letter. The lexer will also matches and returns identifier, considering
that JUMP instruction contains a label without a colon.
The delimiters of the lexer consists of white spaces and comas. But NewLine token however, would be returned as a symbol, as
NewLine tokens separate instruction. It is a mark of the end of an instruction. Newline token also marks the end of a comment
line, which starts by a hashtag token and consists of any combinations of ASCII characters.

parser.cup

the speicification file for Parser, used by a java-cup-11a.jar to construct sym.java and AParser.java.
It matches all the instruction sentences and return them as a list to the main driver of the program.
It will halt the process if symbols cannot be partitioned by the grammar specified. 
The scan mechanism is set as the nexttoken() of the lexer. 

As mentioned in the lexer section, sym.java holds all the terminal symbols that could be used by the lexer.
Non-terminals declared would represent the left-hand-side of a procduction. The one the parsing process to 
begin with will be returned to the main drvier as parsing result. That symbol is declared "lines" in parser.cup
"lines" contains instructions either followed by Newlines or immediately the next instructions. It is delared as 
an arraylist variable and once after every instruction is accepted it updates itself by concatenating the existing
instruction list with the newly formed line. It utlizes right recursion to receive more incoming lines and contains
an episilon procduction to terminate itself when no more instruction is found.
The instruction accepts r-type, i-type and j-type instructions resptively. Any of them can form the non-terminal
"line" along with a NewLine terminal. All operations can be collecetd by these three categories and once accepted,
they are assigend to their corresponding "RESULT" variables, which are returned to their parent productions. 
In each operation the RESULT would be a string, and thus the final instruction list would be string arraylist.
It is constructed with the op-code (specified by sym.java) and followed by a certain number of operands according
to the operation format. Operands would all be integers as all registers and immediate values can be simplified 
this way. All the non-numeric symbols like parenthese would be discarded. Coma, as the delimiter of the interpreter would be used to 
partition the operations.
        (e.g. add $r1, $r0, $r1   ->  6,1,0,1
               disp $r3           ->  17,3
               sb $r2, 9($r2)     ->  15,2,9,2)
In J operation or LABEL line there is an non-numeric operand. In this case, we constrcut the RESULT as the op-code
followed by the label string 
        (e.g. J abc  ->  13,abc
              abc:   ->  21,abc)
note that the label is collected by the parser as an instruction as well, which may or may not be followed by a Newline.
We do this becuase labels would indicate a line index in the .asm file and we wouldn't know what a label is if we return it 
independently. During interpretation we can set the label point to its immeidate next instruction in the the arraylist.

Another funciton of Parser is to detect the overflow of the immediate values. 
Because each register has 8 bits, thus the number assigned to a register must not exceed a two-digit hexadecimal number.
Upon the returning the RESULT of the non-terminal INT, we will check if the numeric value of the immeidate value is greater
than the maximum value a two-digit hex number can represent.


ADriver.java:

the interpreter and the main driver of the program. 
Upon calling and receiving the Symbol result from parse() method. It extracts the .value attribute from that Symbol object, 
which is the reference of the arraylist we construct in the parser and assigns it to op_list, the instruction list of the 
interpreter. After initalizing 4-byte array Regs, the 256-byte array RAM, an int as pc and a String-Integer hashtable for mapping
the labels to the line indeces, we proceed to call interpret()

The first step of interpretion is to collect all the label instructions, which start with the label op-code. Its string would be 
the key and it maps to the next instruction line number. Every time we insert a key-value pair in the hashtable we check if the 
key already has a pair. If it does, the parser would halt and alert that there are duplicated labels. Once after each label is 
mapped to an line index it would removed from the arraylist. Becasue in the parser the label is added as an instruction whereas
the assembly programmer doesn't consider label as an instrution, to prevent the jump operation from branching to the wrong line,
we won't have the labels occupy slots in the instrucion list once we indexify them in the hashtable.

Then perpetual while loop would be in charge of the main interpretation job, where the pc variable would determine which line to
interpret. It first partition the instrucion into parts by calling the split() on the string. 
The first operand is the op-code, which would be used in a subsequent swich-case structure
for the case value. Each operation in the mini-MIPS would have a case here. Each case would examine the operands in its own way.
For example, the add operation would test if the $rs and $rt value overflow the 8-bit limit and assign the value to a place in  
the Regs array. Store-byte operation will calculate the target index in the RAM array and asign the register value to that location.

Regarding the jump operation, the pc will be updated with a new value referenced by the label key in the hashtable. During the next 
run of the while loop, interpretation will go to the pc-referenced instrution. During branch-on-equal interpretation, pc variable will
be incremented by the immeidate value. Other than these two operations, pc will be incremented by 1 normally. When the halt instruction 
activiated, the program will be terminated and exited.
 
